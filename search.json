[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "bReaus\nR, bros and eau!"
  },
  {
    "objectID": "posts/dashboard_self_update/index.html",
    "href": "posts/dashboard_self_update/index.html",
    "title": "Hosting a self updating Quarto dashboard on GitHub",
    "section": "",
    "text": "Dashboards are cool and self updating dashboards are even cooler! This is short insight how to create something like this.\n\n\nIntroduction\nThe idea of having interactivity and updating content on a static website somehow fascinates me! So I tried to use rvest to scrape a german website which hosts relative up-to-date discharge values of rivers in Baden-Würrtemberg. Sadly I was not able to read the table (yet!), but I tried something else.\nThe German Weather Service (DWD) has a R-package called rdwd. It is a great tool to access a lot of different climate data in Germany and the world! So the idea was to build a dashboard to present the recent climate in Freiburg and add more features in the near future.\n\n\nWhat is a Quarto dashboard?\nA Quarto dashboard is a website consisting of one or more pages, where you can visualize your data, do some monitoring and also add interactivity (Shiny and ojs)! To create one yourself, you just have to create a new Quarto project with a .qmd file and change the format to dashboard. Make sure to enable renv and git.\n\nNote: the output file is called index.html, so the website can be hosted later over GitHub pages.\n\n---\ntitle: \"Das Klima in Freiburg\"\nformat: \n  dashboard: \n    output-file: index.html\n---\n\n\nFill the dashboard\nThe first thing to do, is to get the data from the DWD API. Therefore we load the package rdwd and also bit64, which is required. With selectDWD() you can select the location of your station, the variables you want to download and the time resolution. In my case I selected Freiburg, air temperature and precipitation in an hourly resolution. There are many more variables to download, an exact tutorial can be found in the documentation.\n# Load required packages\nrequire(bit64)\nrequire(rdwd)\nrequire(lubridate)\nrequire(plotly)\nrequire(dplyr)\nrequire(tidyr)\nrequire(ggplot2)\n\n\n# get link to DWD station in Freiburg (for temperature and precipitation, hourly)\nlink &lt;- selectDWD(\"Freiburg\", res=\"hourly\", var=c(\"air_temperature\", \"precipitation\"), per=\"recent\")\n\n# download and read DWD data\nfile &lt;- dataDWD(link, read = T, varnames = T)\n\n# get current time and data and make sure tz='Berlin/Germany'\ncurrTime &lt;- as.POSIXct(Sys.time()) + 2*60*60 \nYou can create the layout of the dashboard using ## Row or ## Column in your document. Here I added some value boxes to display the date and time of the last update of the dashboard. For the icon you can use all the Bootstrap Icons. To change the color check out the documentation.\n#| content: valuebox\n#| title: \"Datum\"\nlist(\n  icon = \"calendar-check\",\n  color = \"light\",\n  value = as.Date(currTime)\n)\n#| content: valuebox\n#| title: \"Uhrzeit des letzten Updates\"\nlist(\n  icon = \"clock\",\n  color = \"light\",\n  value = strftime(currTime, format=\"%H:%M\")\n)\nNow we just need to wrangle our data a little and visualize it. I created a ggplot with a facet_wrap() and used ggplotly() to give the graph some interactivity.\n# make a tibble of the downloaded data and tidy up!\ndf &lt;- file$hourly_air_temperature_recent_stundenwerte_TU_01443_akt |&gt; \n  left_join(file$hourly_precipitation_recent_stundenwerte_RR_01443_akt, by = \"MESS_DATUM\") |&gt; \n  select(-c(eor.y,QN_8,QN_9,eor.x,STATIONS_ID.y)) |&gt; \n  pivot_longer(cols = -c(STATIONS_ID.x, MESS_DATUM))\n\n#wanted time period to display the data (in this case 5 days)\ntime_period &lt;- c(as.Date(currTime) - 5, as.Date(currTime))\n\n# Filter the data and rename variables\ndf_plot &lt;- df |&gt; \n  filter(MESS_DATUM &gt;= time_period[1]) |&gt; \n  mutate(name = case_when(\n    name == 'TT_TU.Lufttemperatur' ~ 'Lufttemperatur (°C)',\n    name == 'RF_TU.Relative_Feuchte' ~ 'Relative Feuchte (%)',\n    name == 'R1.Niederschlagshoehe' ~ 'Niederschlagshöhe (mm)',\n    name == 'RS_IND.Niederschlagsindikator' ~ 'Niederschlagsindikator',\n    name == 'WRTR.Niederschlagsform' ~ 'Niederschlagsform'\n  )) |&gt; \n  filter(name == 'Lufttemperatur (°C)' | \n           name == 'Relative Feuchte (%)' |\n           name == 'Niederschlagshöhe (mm)') |&gt; \n  rename(Datum = MESS_DATUM,\n         Wert = value)\n\n# plotting \nggplotly(\n  ggplot(data = df_plot) + \n    geom_line(aes(x = Datum, y = Wert)) + \n    facet_wrap(~name, scales = 'free_y') +\n    theme_bw()\n)\nHey! Now we have a (very simple) dashboard! But we have to render it ourself to get the newest values of the DWD database and can only use it locally. This is where we have to…\n\n\nUse GitHub-actions and -pages to publish the dashboard\nThis next step is actually quite easy. You have to create a new repository on GitHub, init, add remote, add ., commit and push (the usual stuff!) and add a .github folder in your Quarto project. In there you create a folder called workflows and in which you create a file: publish.yml. You can find more information here.\n\n\n.github/workflows/publish.yml\n\non:\n  workflow_dispatch:\n  push:\n    branches: main\n  schedule:\n    - cron: '0 */2 * * *'\n\nname: Quarto Publish\n\njobs:\n  build-deploy:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n    steps:\n      - name: Check out repository\n        uses: actions/checkout@v4\n\n      - name: Set up Quarto\n        uses: quarto-dev/quarto-actions/setup@v2\n\n      - name: Install R\n        uses: r-lib/actions/setup-r@v2\n        with:\n          r-version: '4.2.0'\n\n      - name: Install R Dependencies\n        uses: r-lib/actions/setup-renv@v2\n        with:\n          cache-version: 1\n\n      - name: Render and Publish\n        uses: quarto-dev/quarto-actions/publish@v2\n        with:\n          target: gh-pages\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n\nThe magic happens through the schedule, where you can set a cron expression when to render and publish your dashboard. I have the feeling this is a science to itself so here is a webiste to create the cron expression you desire. In my case I added a cron expression to run the action every two hours. In my time output I realized that there is a time difference of 2 hours from the GitHub servers to central european time, have that in mind!\non:\n  workflow_dispatch:\n  push:\n    branches: main\n  schedule:\n    - cron: '0 */2 * * *'\nThe last thing to do now is to add a branch called gh-pages to your repository and push the publish.yml. Activate Github pages under the setting of your repository and choose gh-pages as the branch to deploy from. Now every two hours and with every push my dashboard will be updated!\n\n\nWhat now?\nThese were really the basics to start a dashboard, but for me there will be some more steps to make the data visualization and information better. You can see the live dashboard under https://carluna.github.io/klima-freiburg/ and view the whole code here: https://github.com/Carluna/klima-freiburg!"
  },
  {
    "objectID": "posts/package_development_rstudio/index.html",
    "href": "posts/package_development_rstudio/index.html",
    "title": "Developing packages in RStudio",
    "section": "",
    "text": "Why to write a package? Packages provide an easy way to share code with others or use it later, saving time by organizing the code and projects in standardized way.\nPhilosophy: anything that can be automated, should be automated.\nPrerequisites: install.packages(c(\"devtools\", \"roxygen2\", \"testthat\", \"knitr\"))"
  },
  {
    "objectID": "posts/package_development_rstudio/index.html#intro",
    "href": "posts/package_development_rstudio/index.html#intro",
    "title": "Developing packages in RStudio",
    "section": "",
    "text": "Why to write a package? Packages provide an easy way to share code with others or use it later, saving time by organizing the code and projects in standardized way.\nPhilosophy: anything that can be automated, should be automated.\nPrerequisites: install.packages(c(\"devtools\", \"roxygen2\", \"testthat\", \"knitr\"))"
  },
  {
    "objectID": "posts/package_development_rstudio/index.html#basic-workflow",
    "href": "posts/package_development_rstudio/index.html#basic-workflow",
    "title": "Developing packages in RStudio",
    "section": "Basic workflow",
    "text": "Basic workflow\n\ncreate package either via devtools::create(path) or via RStudio–&gt;new Project–&gt;new R package\nin case git should be used: devtools::use_git()\nediting functions:\n\nusethis::use_r(\"functionname\") to create a new function script, naming the file after the function. New .R-files for each user-facing function in the package. After adding more functions, these might be grouped.\ncreate roxygen2-skeleton to provide information and document functions via 'Ctrl + Alt + Shift + R'\ndevtools::load_all() to load the created functions under R/ subdirectory\nusethis::use_package() to include functions from other packages (adding them to the Imports field of DESCRIPTION). The function can be used via packagename::fun()\n(git-commit after editing a function)\ndevtools::rename_files(\"old_name\", \"new_name\") to update the function name in files –&gt; Don’t forget to update test-files, too!\n\ncheck that an R package is in full working order with devtools::check() or 'Ctrl + Shift + E', providing a convenient way to run this without leaving the R session\ncreate testing infrastructure via usethis::use_testthat()\n\nusethis::use_test(\"function_name\") to create a test-file for a specific function\ndevtools::test() or 'Ctrl + Shift + T' to run test\n\npick license, e.g. via usethis::use_mit_license(), creating LICENSE and LICENSE.md-files\ncreate and update documentation via devtools::document()\nuse_readme_rmd() initializes a basic, executable README.Rmd file for the github page to describe the purpose of the package, providing installation instructions, and showing a bit of usage. build_readme() renders the file\nInstallation: devtools::check() again, then install package into library via devtools::install()\nPublish: devtools::build()converts package folder/project into single bundled file"
  },
  {
    "objectID": "posts/package_development_rstudio/index.html#structure",
    "href": "posts/package_development_rstudio/index.html#structure",
    "title": "Developing packages in RStudio",
    "section": "Structure",
    "text": "Structure\n\n\n\n\n\n\n\nRecommended folder structure for packages (Posit Software, 2024)\n\n\n\nDESCRIPTION provides metadata about the package\nNAMESPACE declares the functions the package exports for external use and the external functions your package imports from other packages. is automatically edited when using roxygen2\n.Rbuildignore lists files that are needed to be around but should not be included when building the R package from source\n.Rproj.user - directory used internally by RStudio\n.gitignore anticipates Git usage and tells Git to ignore some standard, behind-the-scenes files created by R and RStudio\ntests/ directory in which the testing framework is placed, containing specific tests for the functions"
  },
  {
    "objectID": "posts/package_development_rstudio/index.html#main-functions-during-development",
    "href": "posts/package_development_rstudio/index.html#main-functions-during-development",
    "title": "Developing packages in RStudio",
    "section": "Main functions during development",
    "text": "Main functions during development\nThese functions setup parts of the package and are typically called once per package:\n\ncreate_package()\nuse_git()\nuse_mit_license()\nuse_testthat()\nuse_github()\nuse_readme_rmd()\n\nThese functions are called on a regular basis, as adding functions and tests or taking on dependencies:\n\nuse_r()\nuse_test()\nuse_package()\n\nThese functions are called multiple times per day or per hour, during development:\n\nload_all()\ndocument()\ntest()\ncheck()"
  },
  {
    "objectID": "posts/package_development_rstudio/index.html#main-shortcuts",
    "href": "posts/package_development_rstudio/index.html#main-shortcuts",
    "title": "Developing packages in RStudio",
    "section": "Main shortcuts",
    "text": "Main shortcuts\n\nCtrl + Shift + T - run devtools::test()\nCtrl + Shift + E - run devtools::check()\nCtrl + Shift + Alt + R - create roxygen2 skeleton"
  },
  {
    "objectID": "posts/package_development_rstudio/index.html#package-states",
    "href": "posts/package_development_rstudio/index.html#package-states",
    "title": "Developing packages in RStudio",
    "section": "Package states",
    "text": "Package states\n\nsource - directory of files with specific package structure\nbundled - compressed into single file using extension .tar.gz\nbinary - single platform-specific file\ninstalled - binary package that’s been compressed into a package library\nin-memory - package loaded into memory\n\n\n\n\nMethods for converting between package states (Wickham & Bryan 2023)"
  },
  {
    "objectID": "posts/package_development_rstudio/index.html#more-info",
    "href": "posts/package_development_rstudio/index.html#more-info",
    "title": "Developing packages in RStudio",
    "section": "more info",
    "text": "more info\nWriting R Extensions (r-project.org)\nR packages book (2e)"
  },
  {
    "objectID": "posts/renv_install_packages/index.html",
    "href": "posts/renv_install_packages/index.html",
    "title": "Installing packages for ‘renv’",
    "section": "",
    "text": "renv is a R package that allows to create environments, where the user can install and manage packages. This is needed when using a GitHub action, when you want to render quarto document remote.\nTo use renv it is necessary to install R packages again, even though they are already installed locally. This enables to use GitHub actions to automatically render the Quarto-Project to deploy a GitHub page!\nPackages can be installed normally with install.packages('tidyverse'). Afterwards you can check the status of renv with renv::status(). You can also install all necessary packages (e.g. knitr, markdown,…) by renv::install(). If you installed new packages you have to run renv::snapshot(), to add the installed packages to the lockfile. The lockfile holds all the information about the used packages and when the build and deploy action is performed all the packages will be installed.\n\n\n\nOutput of the build-deploy action on GitHub\n\n\nFor more information on how to use GitHub-actions with Quarto click here!"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "bReaus",
    "section": "",
    "text": "Developing packages in RStudio\n\n\n\n\n\n\ncode\n\n\nr\n\n\npackages\n\n\nrstudio\n\n\n\n\n\n\n\n\n\nJun 18, 2024\n\n\nLeo\n\n\n\n\n\n\n\n\n\n\n\n\nHosting a self updating Quarto dashboard on GitHub\n\n\n\n\n\n\ncode\n\n\nr\n\n\nquarto\n\n\ngithub\n\n\n\n\n\n\n\n\n\nJun 18, 2024\n\n\nRuben\n\n\n\n\n\n\n\n\n\n\n\n\nInstalling packages for ‘renv’\n\n\n\n\n\n\ncode\n\n\nr\n\n\nquarto\n\n\ngithub\n\n\n\n\n\n\n\n\n\nJun 12, 2024\n\n\nRuben\n\n\n\n\n\n\nNo matching items"
  }
]